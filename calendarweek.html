<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>VTuber Schedule – Week Bars (Sun–Sat)</title>

  <script src="js/config.js"></script>

  <style>
    :root {
      --bg: #000;
      --white: #fff;

      /* =========================
         BORDER SETTINGS
         ========================= */
      --borderColor: #fff;
      --borderSize: 4px; /* uniform border thickness */

      /* Today highlight stroke gradient */
      --today1: #2de2e6; /* teal */
      --today2: #2f7dff; /* blue */

      /* Hover highlight stroke gradient */
      --hover1: #2cff6a; /* bright green */
      --hover2: #068037; /* darker green */

      /* ✅ Live stroke gradient (middle section only) */
      --live1: #ff2a2a; /* bright red */
      --live2: #8b0000; /* deep red */

      --blue1: #2e4b78;
      --blue2: #1f345a;

      --rowH: 92px;
      --rowGap: 15px;
      --pointGap: 15px;
      --sideW: 220px;

      /* Shape tuning */
      --slant: 26px;
      --point: 28px;

      /* Row offset tuning */
      --offset: 50px;

      /* Default (no-event) bar fallback */
      --barDefault: #2a3446;

      /* Middle text font (AleaWB) */
      --midFont: "AleaWB", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      /* UI font (Day/Date) */
      --uiFont: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    @font-face {
      font-family: "AleaWB";
      src: url("fnt/ALEAWB__.TTF") format("truetype");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); overflow-x: hidden; }

    body {
      display: grid;
      place-items: center;
      padding: 24px;
      font-family: var(--uiFont);
    }

    .wrap {
      width: min(1200px, 96vw);
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      color: #fff;
    }

    .title {
      font-weight: 900;
      letter-spacing: .04em;
      text-transform: uppercase;
      font-size: 14px;
      opacity: .9;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .btn {
      border: 1px solid rgba(255,255,255,.20);
      background: rgba(255,255,255,.06);
      color: #fff;
      border-radius: 999px;
      padding: 10px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: background .12s ease, transform .06s ease;
      user-select: none;
      font-family: var(--uiFont);
    }
    .btn:hover { background: rgba(255,255,255,.10); }
    .btn:active { transform: translateY(1px); }

    .range {
      font-weight: 900;
      font-size: 14px;
      opacity: .95;
      text-shadow: 0 3px 0 rgba(0,0,0,.8);
    }

    .error {
      color: #fff;
      background: rgba(255,80,80,.16);
      border: 1px solid rgba(255,80,80,.40);
      border-radius: 12px;
      padding: 10px 12px;
      white-space: pre-wrap;
      display: none;
      font-family: var(--uiFont);
    }

    .list {
      display: flex;
      flex-direction: column;
      gap: var(--rowGap);
    }

    .row {
      height: var(--rowH);
      display: grid;
      grid-template-columns: var(--sideW) 1fr var(--sideW);
      gap: 0px;
      align-items: stretch;
      transform: translateX(var(--rowShift, 0px));
      transition: transform .15s ease;
      overflow: visible;
    }

    .row.shift-left  { --rowShift: calc(var(--offset) * -1); }
    .row.shift-right { --rowShift: var(--offset); }

    /* =========================
       SHAPES
       ========================= */
    .shape {
      position: relative;
      overflow: visible;
      filter: drop-shadow(0 6px 0 rgba(0,0,0,0.80));
      min-height: 1px;
    }

    /* Fill layer */
    .shape::after {
      content: "";
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }

    /* SVG stroke overlay */
    .strokeSvg {
      position: absolute;
      inset: 0;
      z-index: 4;
      pointer-events: none;
      overflow: visible;
    }
    .strokeSvg polygon {
      fill: none;
      stroke: var(--borderColor);
      stroke-width: var(--borderSize);
      vector-effect: non-scaling-stroke;
      stroke-linejoin: miter;
      stroke-miterlimit: 4;
    }

    /* Today highlight: gradient stroke for all 3 shapes in the row */
    .row.today .strokeSvg polygon{
      stroke: url(#todayStroke);
    }

    /* Hover highlight: whole row reacts when mouse is over any part */
    .row:hover .strokeSvg polygon{
      stroke: url(#hoverStroke);
    }

    /* ✅ Live border: ONLY the middle bar stroke becomes red gradient */
    .row.live .bar .strokeSvg polygon{
      stroke: url(#liveStroke) !important;
    }

    .content-layer {
      position: relative;
      z-index: 5;
      height: 100%;
      display: flex;
      align-items: center;
      padding: 0 20px;
    }

    /* LEFT ARROW: make pattern variable per-row */
    .arrow { --leftPattern: url("img/06.png"); } /* default */
    .arrow::after {
      clip-path: polygon(
        0% 50%,
        var(--point) 0%,
        100% 0%,
        calc(100% - var(--slant)) 100%,
        var(--point) 100%,
        0% 50%
      );
      background:
        var(--leftPattern) 0 0 / auto repeat,
        linear-gradient(135deg, rgba(255,255,255,.10), rgba(0,0,0,.22));
    }

    /* MIDDLE BAR */
    .bar {
      margin-left: calc(-1 * (var(--slant) - var(--pointGap)));
      --barPattern: none;
    }
    .bar::after {
      clip-path: polygon(
        var(--slant) 0%,
        100% 0%,
        calc(100% - var(--slant)) 100%,
        0% 100%
      );
      background:
        radial-gradient(120px 80px at 20% 30%, rgba(255,255,255,.10), transparent 60%),
        linear-gradient(135deg, rgba(255,255,255,.08), rgba(0,0,0,.20)),
        var(--barPattern) 0 0 / auto repeat,
        var(--barDefault);
    }

    /* RIGHT BOX */
    .arrowR {
      margin-left: calc(-1 * (var(--slant) - var(--pointGap)));
      --thumb: none;
    }
    .arrowR::after {
      clip-path: polygon(
        var(--slant) 0%,
        calc(100% - var(--point)) 0%,
        100% 50%,
        calc(100% - var(--point)) 100%,
        0% 100%
      );
      background:
        var(--thumb) center/cover,
        linear-gradient(180deg, var(--blue1), var(--blue2));
    }

    /* left text */
    .kanjiBox {
      width: 70px; height: 70px;
      display: grid; place-items: center;
      color: var(--white);
      font-weight: 900;
      font-size: 44px;
      line-height: 1;
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.85));
      margin-right: 6px;
      flex: 0 0 auto;
      font-family: var(--uiFont);
    }

    .dowWrap{
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      line-height: 1;
      gap: 3px;
      transform: translateY(-3px);
      flex: 0 0 auto;
      font-family: var(--uiFont);
    }

    .dow, .date {
      color: #fff;
      font-weight: 900;
      font-size: 32px;
      text-transform: uppercase;
      text-shadow: 0 4px 0 rgba(0,0,0,.85);
      font-family: var(--uiFont);
    }

    .date {
      letter-spacing: .02em;
      opacity: .95;
    }

    /* ===== Center bar text layout ===== */
    .midContent {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 14px;
      min-width: 0;
    }

    /* ONE LINE title (subtitle if found; else main title) */
    .eventMain {
      flex: 1;
      min-width: 0;
      font-family: var(--midFont);
      color: #fff;
      font-weight: 900;
      font-size: clamp(22px, 2.2vw, 44px);
      text-shadow: 0 5px 0 rgba(0,0,0,.85);
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding: 0 10px;
    }

    /* Time uses AleaWB, scooted from right edge */
    .eventTime {
      font-family: var(--midFont);
      color: #fff;
      font-weight: 900;
      font-size: clamp(14px, 1.2vw, 22px);
      text-transform: uppercase;
      text-shadow: 0 4px 0 rgba(0,0,0,.85);
      white-space: nowrap;
      flex: 0 0 auto;
      margin-left: auto;
      padding-right: 6px; /* ✅ scoot left */
    }

    /* YouTube icons container (replaces time) */
    .ytIcons {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-left: auto;
      padding-right: 6px; /* same “scoot left” */
      flex: 0 0 auto;
    }

    /* ✅ Link wrapper: NO box, but still easy to click */
    .ytLink {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px;             /* click padding without a visible box */
      margin: 0;
      border: 0;
      background: transparent;
      text-decoration: none;
      line-height: 0;           /* removes baseline “mystery box” */
      border-radius: 8px;       /* for focus ring */
      transition: transform .10s ease, filter .10s ease;
    }

    /* ✅ Preserve icon ratio: height fixed, width auto */
    .ytIcon {
      height: 22px;
      width: auto;
      display: block;
      object-fit: contain;
      image-rendering: auto; /* keeps your pixel art crisp */
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.70));
    }

    /* Keep the hover pop effect */
    .ytLink:hover {
      transform: translateY(-1px) scale(1.08);
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.55));
    }
    .ytLink:active {
      transform: translateY(0px) scale(1.02);
    }

    /* Nice keyboard focus without a big box normally */
    .ytLink:focus-visible{
      outline: 2px solid rgba(255,255,255,.65);
      outline-offset: 2px;
    }

    /* =========================
       ✅ Twitch Live swap UI (today row only)
       ========================= */
    .rightSlot{
      display: flex;
      align-items: center;
      gap: 10px;
      margin-left: auto;
      padding-right: 6px; /* matches your “scoot left” */
      flex: 0 0 auto;
    }

    .twitchWrap{ display: none; }

    .twitchLink{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      background: transparent;
      border: 0;
      text-decoration: none;
      line-height: 0;
      border-radius: 8px;
      transition: transform .10s ease, filter .10s ease;
    }
    .twitchLink:hover{
      transform: translateY(-1px) scale(1.08);
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.55));
    }
    .twitchLink:active{
      transform: translateY(0px) scale(1.02);
    }
    .twitchLink:focus-visible{
      outline: 2px solid rgba(255,255,255,.65);
      outline-offset: 2px;
    }

    .twitchIcon{
      height: 36px;
      width: auto;
      display: block;
      object-fit: contain;
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.70));
    }

    /* When live: show Twitch badge, hide time + yt icons (middle bar only) */
    .row.live .twitchWrap{ display: flex; }
    .row.live .eventTime{ display: none; }
    .row.live .ytIcons{ display: none; }

    @media (max-width: 800px) {
      :root {
        --sideW: 200px;
        --rowH: 82px;
        --slant: 22px;
        --point: 24px;
        --offset: 16px;
      }
      .kanjiBox { width: 62px; height: 62px; font-size: 38px; }
      .dow, .date { font-size: 28px; }
      .dowWrap { transform: translateY(-3px); gap: 3px; }
      .ytIcon { height: 20px; }
      .twitchIcon { height: 20px; }
    }
  </style>
</head>

<body>
  <!-- Gradient def used by today's border & hover border -->
  <svg width="0" height="0" style="position:absolute">
    <defs>
      <linearGradient id="todayStroke" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="var(--today1)"/>
        <stop offset="100%" stop-color="var(--today2)"/>
      </linearGradient>
      <linearGradient id="hoverStroke" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="var(--hover1)"/>
        <stop offset="100%" stop-color="var(--hover2)"/>
      </linearGradient>

      <!-- ✅ Live red gradient (middle section only) -->
      <linearGradient id="liveStroke" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="var(--live1)"/>
        <stop offset="100%" stop-color="var(--live2)"/>
      </linearGradient>
    </defs>
  </svg>

  <div class="wrap">
    <div class="topbar">
      <div class="title">Weekly Schedule</div>
      <div class="controls">
        <button class="btn" id="prevBtn">◀ Prev</button>
        <button class="btn" id="todayBtn">This Week</button>
        <button class="btn" id="nextBtn">Next ▶</button>
        <div class="range" id="rangeLabel"></div>
      </div>
    </div>
    <div class="error" id="errorBox"></div>
    <div class="list" id="list"></div>
  </div>

<script>
const cfg = window.GCAL_CONFIG || {};
const GOOGLE_API_KEY = cfg.apiKey;
const CALENDAR_SHARE_LINK = cfg.calendarShareLink;

const IMAGE_BASE_URL = "img/";
const IMAGE_EXTENSION = ".png";

/* ✅ WHERE YOUR QUEST JSON FILES LIVE */
const QUEST_JSON_BASE_URL = "json/";   // change to "./" if the json sits beside the html

/* YouTube icon (in img folder) */
const YT_ICON_URL = "img/youtube.png";

/* ✅ Twitch (in img folder) */
const TWITCH_URL = "https://twitch.tv/narishm";
const TWITCH_ICON_URL = "img/twitch.png"; // put your provided image here

/* OFF defaults */
const OFF_MAIN = "OFF";
const OFF_BAR_CODE = "00";
const OFF_THUMB_CODE = "off";

/* If a driver event is all-day, assume 12 PM America/New_York */
const FALLBACK_ALLDAY_HOUR_LOCAL = 12;      // 12 PM
const FALLBACK_ALLDAY_MINUTE_LOCAL = 0;
const FALLBACK_ALLDAY_TZ = "America/New_York";

/* Packed token delimiter for YouTube codes */
const YT_DELIM = "~";

const DAYS = [
  { name:"sun", kanji:"日" }, { name:"mon", kanji:"月" }, { name:"tue", kanji:"火" },
  { name:"wed", kanji:"水" }, { name:"thu", kanji:"木" }, { name:"fri", kanji:"金" },
  { name:"sat", kanji:"土" },
];

const listEl = document.getElementById("list");
const rangeLabel = document.getElementById("rangeLabel");
const errorBox = document.getElementById("errorBox");

function showError(msg){ errorBox.style.display = "block"; errorBox.textContent = msg; }
function clearError(){ errorBox.style.display = "none"; errorBox.textContent = ""; }

function pad(n){ return String(n).padStart(2,"0"); }
function ymd(d){ return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`; }
function startOfDayLocal(d){ const x = new Date(d); x.setHours(0,0,0,0); return x; }
function addDays(d, n){ const x = new Date(d); x.setDate(x.getDate() + n); return x; }
function startOfWeekSunday(d){
  const x = startOfDayLocal(d);
  const start = new Date(x);
  start.setDate(x.getDate() - x.getDay());
  start.setHours(0,0,0,0);
  return start;
}

function formatRangeLabel(weekStart){
  const end = addDays(weekStart, 6);
  return `${weekStart.toLocaleDateString(undefined,{month:'short', day:'numeric'})} – ${end.toLocaleDateString(undefined,{month:'short', day:'numeric', year:'numeric'})}`;
}

function formatMMDD(d){
  return `${d.getMonth()+1}/${d.getDate()}`;
}

/* parse: "The DevQuest - 12 PM EST" (now we only care about main) */
function parseCalendarTitle(raw){
  let rest = String(raw || "").trim();

  // remove trailing " - anything" (old time suffix), keep the core title
  const t = rest.match(/\s*-\s*([^-]+)$/);
  if(t) rest = rest.slice(0, t.index).trim();

  return { slot: null, main: rest.trim() };
}

/* Local time formatting (AM/PM, drop :00) */
function formatViewerLocalTime(date){
  const raw = new Intl.DateTimeFormat(undefined, {
    hour: "numeric",
    minute: "2-digit",
    hour12: true
  }).format(date);

  return raw.replace(":00","").toUpperCase();
}

/* ✅ Live ticker state */
let liveTicker = null;
let liveTarget = null; // { rowEl, startMs, endMs }

function getEventRangeMillis(ev){
  // Only timed events (dateTime) get a live window.
  if(ev?.start?.dateTime){
    const startMs = new Date(ev.start.dateTime).getTime();
    // If end is missing, assume 2 hours.
    const endMs = ev?.end?.dateTime
      ? new Date(ev.end.dateTime).getTime()
      : (startMs + 2 * 60 * 60 * 1000);

    return { startMs, endMs };
  }
  return null;
}

function updateLiveState(){
  if(!liveTarget) return;
  const now = Date.now();
  const isLive = now >= liveTarget.startMs && now < liveTarget.endMs;
  liveTarget.rowEl.classList.toggle("live", isLive);
}

/* Create a Date that represents "YYYY-MM-DD at 12:00 in America/New_York" (fallback for all-day) */
function buildDateFromYMDInTZ(ymdStr, hour, minute, timeZone){
  const [Y, M, D] = ymdStr.split("-").map(n => parseInt(n, 10));
  const guessUTC = new Date(Date.UTC(Y, (M-1), D, hour, minute, 0));

  const fmt = new Intl.DateTimeFormat("en-US", {
    timeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false
  });

  function partsToStamp(dt){
    const parts = fmt.formatToParts(dt);
    const get = (t) => parts.find(p => p.type === t)?.value;
    return {
      y: parseInt(get("year"), 10),
      m: parseInt(get("month"), 10),
      d: parseInt(get("day"), 10),
      hh: parseInt(get("hour"), 10),
      mm: parseInt(get("minute"), 10),
      ss: parseInt(get("second"), 10),
    };
  }

  const p = partsToStamp(guessUTC);
  const desiredUTC = Date.UTC(Y, (M-1), D, hour, minute, 0);
  const gotUTC = Date.UTC(p.y, (p.m-1), p.d, p.hh, p.mm, p.ss);

  const deltaMs = desiredUTC - gotUTC;
  return new Date(guessUTC.getTime() + deltaMs);
}

/* ✅ robust cid decode */
function padBase64(b64){ const mod=b64.length%4; return mod ? b64 + "=".repeat(4-mod) : b64; }
function decodeCidToCalendarId(cid){
  try { return atob(padBase64(cid.replace(/-/g,"+").replace(/_/g,"/"))); }
  catch { return null; }
}
function extractCalendarIdFromShareLink(urlStr){
  try {
    const u = new URL(urlStr);
    const cid = u.searchParams.get("cid");
    return cid ? decodeCidToCalendarId(cid) : null;
  } catch { return null; }
}

/* ✅ paging-safe fetch */
async function fetchAllEvents(calendarId, timeMinISO, timeMaxISO){
  const base = `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`;
  let pageToken = null;
  const all = [];

  while(true){
    const url = new URL(base);
    url.searchParams.set("key", GOOGLE_API_KEY);
    url.searchParams.set("timeMin", timeMinISO);
    url.searchParams.set("timeMax", timeMaxISO);
    url.searchParams.set("singleEvents","true");
    url.searchParams.set("orderBy","startTime");
    url.searchParams.set("maxResults","2500");
    if(pageToken) url.searchParams.set("pageToken", pageToken);

    const res = await fetch(url.toString());
    const data = await res.json();
    if(!res.ok) throw new Error(data?.error?.message || "Calendar API error");

    if(Array.isArray(data.items)) all.push(...data.items);
    pageToken = data.nextPageToken;
    if(!pageToken) break;
  }

  return all;
}

/* ✅ multi-day coverage map */
function coveredDayKeys(ev){
  let start, endExclusive;

  if(ev?.start?.date){
    start = new Date(ev.start.date + "T00:00:00");
    endExclusive = ev?.end?.date ? new Date(ev.end.date + "T00:00:00")
                                 : new Date(start.getTime() + 86400000);
  } else if(ev?.start?.dateTime){
    start = new Date(ev.start.dateTime);
    endExclusive = ev?.end?.dateTime ? new Date(ev.end.dateTime)
                                     : new Date(start.getTime() + 3600000);
  } else {
    return [];
  }

  const startDay = startOfDayLocal(start);
  const lastTouched = new Date(endExclusive.getTime() - 1);
  const endDay = startOfDayLocal(lastTouched);

  const keys = [];
  for(let d = new Date(startDay); d <= endDay; d.setDate(d.getDate()+1)){
    keys.push(ymd(d));
  }
  return keys;
}

function startMillis(ev){
  if(ev?.start?.dateTime) return new Date(ev.start.dateTime).getTime();
  if(ev?.start?.date) return new Date(ev.start.date + "T00:00:00").getTime();
  return Number.POSITIVE_INFINITY;
}

/* ✅ Pick the EARLIEST event (by startMillis) */
function sortEventsForDay(list){
  return list.sort((a,b)=>{
    const sa=startMillis(a), sb=startMillis(b);
    if(sa!==sb) return sa-sb;
    return String(a?.summary||"").localeCompare(String(b?.summary||""));
  });
}

function normalizeDescription(desc){
  const s = String(desc||"");
  const noHtml = s.replace(/<[^>]+>/g,"");
  const firstLine = noHtml.split(/\r?\n/)[0];
  return firstLine.trim();
}

/*
  Packed token examples:
    "03tdqlct"
    "03tdqlct~dQw4w9WgXcQ"
    "03tdqlct~id1~id2~id3"
*/
function parsePackedToken(ev){
  const token = normalizeDescription(ev?.description || "").split(/\s+/)[0].trim();
  if(!token) return { barCode: null, thumbCode: null, ytIds: [] };

  const parts = token.split(YT_DELIM).filter(Boolean);
  const head = parts[0] || "";
  const m = head.match(/^(\d{2})([A-Za-z0-9_-]+)$/);

  const barCode = m ? m[1] : null;
  const thumbCode = m ? m[2] : null;

  // Remaining parts are YouTube video IDs (or live IDs)
  const ytIds = parts.slice(1).map(s => s.trim()).filter(Boolean);

  return { barCode, thumbCode, ytIds };
}

function codeToImageUrl(code){
  return IMAGE_BASE_URL + encodeURIComponent(code) + IMAGE_EXTENSION;
}

/* ✅ driver event = earliest event of the day */
function pickDriverEventForDay(list){
  const sorted = sortEventsForDay([...list]);
  return sorted[0] || null;
}

/* =========================
   ✅ QUEST JSON LOOKUP
   ========================= */
const questJsonCache = new Map();

function questTitleToFilename(mainTitle){
  return String(mainTitle || "")
    .trim()
    .replace(/\s+/g,"")
    .toLowerCase() + ".json";
}

function deepFindTitleById(root, targetId){
  if(!root || !targetId) return null;

  if(Array.isArray(root)){
    for(const item of root){
      const r = deepFindTitleById(item, targetId);
      if(r) return r;
    }
    return null;
  }

  if(typeof root === "object"){
    if(root.id === targetId && typeof root.title === "string" && root.title.trim()){
      return root.title.trim();
    }
    for(const k of Object.keys(root)){
      const r = deepFindTitleById(root[k], targetId);
      if(r) return r;
    }
  }
  return null;
}

async function fetchQuestJson(filename){
  if(questJsonCache.has(filename)) return questJsonCache.get(filename);

  try{
    const res = await fetch(QUEST_JSON_BASE_URL + filename, { cache: "no-store" });
    if(!res.ok){
      questJsonCache.set(filename, null);
      return null;
    }
    const data = await res.json();
    questJsonCache.set(filename, data);
    return data;
  } catch {
    questJsonCache.set(filename, null);
    return null;
  }
}

async function lookupSubtitleFromQuestJson(mainTitle, thumbCode){
  if(!mainTitle || !thumbCode) return null;
  const filename = questTitleToFilename(mainTitle);
  const json = await fetchQuestJson(filename);
  if(!json) return null;
  return deepFindTitleById(json, thumbCode);
}

/* =========================
   SVG STROKE BORDER (uniform)
   ========================= */
function cssPx(varName){
  const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : 0;
}

const strokeJobs = [];
function queueStroke(shapeEl, kind){
  strokeJobs.push({ el: shapeEl, kind });
}

function ensureStrokeSvg(shapeEl){
  let svg = shapeEl.querySelector(":scope > svg.strokeSvg");
  if(svg) return svg;

  svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
  svg.classList.add("strokeSvg");

  const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
  svg.appendChild(poly);

  shapeEl.appendChild(svg);
  return svg;
}

function setPolygonPoints(poly, pts){
  poly.setAttribute("points", pts.map(p => `${p[0]},${p[1]}`).join(" "));
}

function applyStrokes(){
  const slant = cssPx("--slant");
  const point = cssPx("--point");

  while(strokeJobs.length){
    const { el, kind } = strokeJobs.shift();
    const w = el.clientWidth;
    const h = el.clientHeight;
    if(!w || !h) continue;

    const svg = ensureStrokeSvg(el);
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    svg.setAttribute("preserveAspectRatio","none");

    const poly = svg.querySelector("polygon");

    if(kind === "arrowL"){
      setPolygonPoints(poly, [
        [0, h/2],
        [point, 0],
        [w, 0],
        [w - slant, h],
        [point, h],
        [0, h/2],
      ]);
    } else if(kind === "bar"){
      setPolygonPoints(poly, [
        [slant, 0],
        [w, 0],
        [w - slant, h],
        [0, h],
      ]);
    } else if(kind === "arrowR"){
      setPolygonPoints(poly, [
        [slant, 0],
        [w - point, 0],
        [w, h/2],
        [w - point, h],
        [0, h],
      ]);
    }
  }
}

function scheduleStrokeApply(){
  requestAnimationFrame(() => applyStrokes());
}
window.addEventListener("resize", () => scheduleStrokeApply());

function makeRow(day, dateText, mainTitle, subTitle, timeText, ytIds, rowIndex, leftPatternUrl, barPatternUrl, thumbUrl, allowTwitch){
  const row = document.createElement("div");
  row.className = `row ${rowIndex % 2 === 0 ? 'shift-left' : 'shift-right'}`;

  // Left
  const arrow = document.createElement("div");
  arrow.className = "shape arrow";
  if(leftPatternUrl){
    arrow.style.setProperty("--leftPattern", `url("${leftPatternUrl.replace(/"/g,'\\"')}")`);
  }

  const leftContent = document.createElement("div");
  leftContent.className = "content-layer";

  const kanji = document.createElement("div");
  kanji.className = "kanjiBox";
  kanji.textContent = day.kanji;

  const dowWrap = document.createElement("div");
  dowWrap.className = "dowWrap";

  const dow = document.createElement("div");
  dow.className = "dow";
  dow.textContent = day.name;

  const dateEl = document.createElement("div");
  dateEl.className = "date";
  dateEl.textContent = dateText;

  dowWrap.appendChild(dow);
  dowWrap.appendChild(dateEl);

  leftContent.appendChild(kanji);
  leftContent.appendChild(dowWrap);
  arrow.appendChild(leftContent);

  // Center
  const bar = document.createElement("div");
  bar.className = "shape bar";
  if(barPatternUrl){
    bar.style.setProperty("--barPattern", `url("${barPatternUrl.replace(/"/g,'\\"')}")`);
  }

  const midContent = document.createElement("div");
  midContent.className = "content-layer";

  const midInner = document.createElement("div");
  midInner.className = "midContent";

  const mainEl = document.createElement("div");
  mainEl.className = "eventMain";
  mainEl.textContent = (subTitle && subTitle.trim()) ? subTitle : (mainTitle || "");

  midInner.appendChild(mainEl);

  // ✅ Right side slot: Twitch (live), YT icons, or time
  const rightSlot = document.createElement("div");
  rightSlot.className = "rightSlot";

  // Twitch badge (hidden unless .row.live)
  if(allowTwitch){
    const twWrap = document.createElement("div");
    twWrap.className = "twitchWrap";

    const a = document.createElement("a");
    a.className = "twitchLink";
    a.href = TWITCH_URL;
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    a.title = "Watch live on Twitch";

    const img = document.createElement("img");
    img.className = "twitchIcon";
    img.src = TWITCH_ICON_URL;
    img.alt = "Twitch";

    a.appendChild(img);
    twWrap.appendChild(a);
    rightSlot.appendChild(twWrap);
  }

  // YouTube icons (shown when not live)
  if(Array.isArray(ytIds) && ytIds.length){
    const ytWrap = document.createElement("div");
    ytWrap.className = "ytIcons";

    for(const id of ytIds){
      const a = document.createElement("a");
      a.className = "ytLink";
      a.href = `https://www.youtube.com/watch?v=${encodeURIComponent(id)}`;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.title = "Open YouTube VOD";

      const img = document.createElement("img");
      img.className = "ytIcon";
      img.src = YT_ICON_URL;
      img.alt = "YouTube";

      a.appendChild(img);
      ytWrap.appendChild(a);
    }

    rightSlot.appendChild(ytWrap);
  }
  // Time (shown when not live and no YT icons)
  else if(timeText){
    const eventTime = document.createElement("div");
    eventTime.className = "eventTime";
    eventTime.textContent = timeText;
    rightSlot.appendChild(eventTime);
  }

  if(rightSlot.childNodes.length){
    midInner.appendChild(rightSlot);
  }

  midContent.appendChild(midInner);
  bar.appendChild(midContent);

  // Right
  const arrowR = document.createElement("div");
  arrowR.className = "shape arrowR";
  if(thumbUrl){
    arrowR.style.setProperty("--thumb", `url("${thumbUrl.replace(/"/g,'\\"')}")`);
  }

  row.appendChild(arrow);
  row.appendChild(bar);
  row.appendChild(arrowR);

  // Queue uniform SVG borders
  queueStroke(arrow, "arrowL");
  queueStroke(bar, "bar");
  queueStroke(arrowR, "arrowR");

  return row;
}

let cursorDate = new Date();

async function refreshWeek(){
  clearError();
  listEl.innerHTML = "";

  // reset live targeting each render
  liveTarget = null;
  if(liveTicker){ clearInterval(liveTicker); liveTicker = null; }

  if(!window.GCAL_CONFIG) return showError("Missing js/config.js (window.GCAL_CONFIG not found).");
  if(!GOOGLE_API_KEY || !CALENDAR_SHARE_LINK) return showError("js/config.js must provide { apiKey, calendarShareLink }.");

  const calendarId = extractCalendarIdFromShareLink(CALENDAR_SHARE_LINK);
  if(!calendarId) return showError("Invalid Calendar Link (cid decode failed).");

  const weekStart = startOfWeekSunday(cursorDate);
  const weekEndExclusive = addDays(weekStart, 7);
  rangeLabel.textContent = formatRangeLabel(weekStart);

  const todayKey = ymd(new Date());

  try {
    const events = await fetchAllEvents(calendarId, weekStart.toISOString(), weekEndExclusive.toISOString());

    const byDay = new Map();
    for(const ev of events){
      for(const k of coveredDayKeys(ev)){
        if(!byDay.has(k)) byDay.set(k, []);
        byDay.get(k).push(ev);
      }
    }

    for(let i=0; i<7; i++){
      const dayDate = addDays(weekStart, i);
      const dayKey = ymd(dayDate);
      const mmdd = formatMMDD(dayDate);

      // Left panel pattern: past=00, today=07, future=06
      let leftPatternCode = "06";
      if(dayKey < todayKey) leftPatternCode = "00";
      else if(dayKey === todayKey) leftPatternCode = "07";
      const leftPatternUrl = codeToImageUrl(leftPatternCode);

      const evs = byDay.get(dayKey) || [];
      const driver = evs.length ? pickDriverEventForDay(evs) : null;

      let mainTitle = OFF_MAIN;
      let subTitle = "";
      let timeText = "";
      let ytIds = [];
      let barPatternUrl = codeToImageUrl(OFF_BAR_CODE);
      let thumbUrl = codeToImageUrl(OFF_THUMB_CODE);

      if(driver){
        const packed = parsePackedToken(driver);
        const parts = parseCalendarTitle(driver.summary || "");

        mainTitle = (parts.main || "").trim() || (packed.thumbCode ? packed.thumbCode : "Untitled");

        if(packed.barCode) barPatternUrl = codeToImageUrl(packed.barCode);
        if(packed.thumbCode) thumbUrl = codeToImageUrl(packed.thumbCode);

        // YouTube IDs (if present) replace time
        ytIds = Array.isArray(packed.ytIds) ? packed.ytIds : [];

        if(mainTitle && packed.thumbCode){
          const jsonSub = await lookupSubtitleFromQuestJson(mainTitle, packed.thumbCode);
          if(jsonSub) subTitle = jsonSub;
        }

        // TIME:
        // - If YouTube IDs exist, we do NOT render time (icons replace it)
        // - Else show viewer-local time from Google Calendar
        // - If all-day, assume 12 PM America/New_York and convert to viewer-local
        if(!ytIds.length){
          if(driver.start?.dateTime){
            timeText = formatViewerLocalTime(new Date(driver.start.dateTime));
          } else if(driver.start?.date){
            const fallback = buildDateFromYMDInTZ(
              driver.start.date,
              FALLBACK_ALLDAY_HOUR_LOCAL,
              FALLBACK_ALLDAY_MINUTE_LOCAL,
              FALLBACK_ALLDAY_TZ
            );
            timeText = formatViewerLocalTime(fallback);
          }
        }
      }

      const isToday = (dayKey === todayKey);
      const allowTwitch = isToday; // only TODAY row gets the Twitch swap

      const rowEl = makeRow(
        DAYS[i],
        mmdd,
        mainTitle,
        subTitle,
        timeText,
        ytIds,
        i,
        leftPatternUrl,
        barPatternUrl,
        thumbUrl,
        allowTwitch
      );

      if(isToday) rowEl.classList.add("today");
      listEl.appendChild(rowEl);

      // If TODAY and we have a timed driver event, arm the live window
      if(isToday && driver){
        const range = getEventRangeMillis(driver);
        if(range){
          liveTarget = { rowEl, startMs: range.startMs, endMs: range.endMs };
        }
      }
    }

    scheduleStrokeApply();

    // Live ticker: updates without refetching calendar data
    updateLiveState();
    liveTicker = setInterval(updateLiveState, 15000);

  } catch(e) {
    showError(e?.message || String(e));
  }
}

document.getElementById("todayBtn").onclick = () => { cursorDate = new Date(); refreshWeek(); };
document.getElementById("prevBtn").onclick = () => { cursorDate = addDays(startOfWeekSunday(cursorDate), -7); refreshWeek(); };
document.getElementById("nextBtn").onclick = () => { cursorDate = addDays(startOfWeekSunday(cursorDate), 7); refreshWeek(); };

refreshWeek();
</script>
</body>
</html>
